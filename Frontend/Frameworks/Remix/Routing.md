- Remix has a built-in router that enables you to easily map URLs and route parameters to files in your application's `app/routes` directory. Run the command `npx remix routes` to view the generated routes.
# Nested routes
- For nested routes, use the `<Outlet/>` component as a *layout* wrapper for child layouts:
```tsx
// When you navigate to `/parent/child` path, you'll see "Parent" above "Child". If we swap the `<h1>` and `<Outlet />` in the parent, then the child will be above the parent. The parent gets to decide where its child goes.
//-----------------------------------
// app/routes/parent.tsx
export default function Parent() {
	return (
		<div>
			<h1>Parent</h1>
			<Outlet />
		</div>
	)
}

// app/routes/child.tsx
export default function Child() {
	return <h2>Child</h2>
}
```

## Conventions
### Flat routes
- Enabled by the [remix-flat-routes](https://github.com/kiliman/remix-flat-routes) package, the `+` (or a `.` that's not right before the file extension) in a pathname indicates a parent segment. For example, path `users/random` will be defined (in your project's structure) as `routes/users+/random.tsx` or `routes/users.random.tsx` where the former enables a hierarchy in directory manner (`routes > users+ > random.tsx`) where the latter is defined as `routes/users.random.tsx`. In this case, the entire UI generated by `random.tsx` is included in the `/users` path.
  > It's good practice to go as far as 3 levels of nested routes using the `+` convention. Any deeper than that should be defined using the `.`

- If you want a child pathname segment to have its **UI separated to a new page** (i.e. its layout is decoupled from the UI of its *direct* parent pathname), add an underscore (`_`) to its parent. For example, the `users/username/notes` path will have the UI of `notes.tsx` decoupled from `users/username` if we define the route as `routes/users+/username_+/notes.tsx`. In this case, `users/username` and `users/username/note` pathnames are treated as siblings (i.e. the `users/username/note` UI doesn't include the UI from `users/username`).
  > It's good practice to have the underscore precede the `+`

### Index route
- Use an index route in case you want a dedicated UI for a parent path by adding a `.index` right before the file extension. For example within the file path `routes/users+/random_+/note.index.tsx`, you'll have a dedicated UI when visiting `/users/random/note` which doesn't persist through `users/random/note/some-note`.
	  If you don't have an index route and put that "index UI" part to the `routes/users+/random_+/note.tsx` file instead, you'll get a clustered UI when visiting `users/random/note/some-note` because the UI of `some-note.tsx` is now rendered on top of that "index UI" part.

### Route params
- Define your route segments dynamically by having the `$` precedes the corresponding file name:
```ts
Route definition: app/routes/chats+/$chatId.messages.tsx
					  // ^ Route param
Resulting path: /chats/whatever/messages 
```
- You can get the param value (e.g. `whatever` from the above example) from [`useParams()`](https://remix.run/docs/en/main/hooks/use-params) which you can `import` from `@remix-run/react`:
```tsx
import { useParams } from '@remix-run/react'

export default function PetRoute() {
	const params = useParams()
	return <h1>Hello {params.chatId}</h1>  // Hello whatever
}
```

# Resource routes
- Think of them as side-effect routes. Preferred in use cases for ***URLs that don't return UI***, e.g. use the path `/images/some-image-id` to get an image. These kind of route requests expect JSON, or plaintext, or an image. In some cases these requests could be non-GET requests as well.
- Resource routes are designed to be standalone and handle their own data fetching, which means that the [`loader`](https://remix.run/docs/en/main/route/loader) in the `app/root.tsx` will not be run whenever we access a resource route. 
- A quick tip to differentiate between a regular route and a resource route is that the resource route's definition file ***doesn't*** have a `export default` component in it.

# Links
- Use the `<Links/>` component to dynamically access the HTML `<link/>` tags from anywhere in your project (that being said, in those files that don't have access to the `<head/>` tag). For example, you can use the `links` to apply [[Routing#Resource routes |resource routes]] from any page, in this case, all the text from the `user/username` will be red, but its sibling route, e.g. `/users/username/notes` is unaffected:
```tsx
// Resource route: app > routes > resources+ > paint-it-red.tsx
export async function loader() {
	return new Response('body { color: red !important }', {
		headers : {
			'content-type': 'text/css'
		}
	})
}

// In a resource consumer route: app > routes > users+ > $username.tsx
import { type LinksFunction } from '@remix-run/node'
import { Link, useParams } from '@remix-run/react'

export const links: LinksFunction = () => {
	return [{ rel: 'stylesheet', href: '/resources/paint-it-red' }]
}

export default function UserProfile() {...some tsx}
```

- You can also get your resources dynamically cached on the browser:
```tsx
import { type LinksFunction } from '@remix-run/node'
import { Links } from '@remix-run/react'
import faviconAssetUrl from './assets/favicon.svg'
import fontStylesheetUrl from './styles/font.css'
import tailwindStylesheetUrl from './styles/tailwind.css'

// The browser automatically invalidates the cache whenever there's an update on these resources:
export const links: LinksFunction = () => {
	return [
		{ rel: 'icon', type: 'image/svg+xml', href: faviconAssetUrl },
		{ rel: 'stylesheet', href: fontStylesheetUrl },
		{ rel: 'stylesheet', href: tailwindStylesheetUrl },
	]
}

export default function App() {
	return (
		<html lang="en">
			<head>
			{/* Using Remix's <Links/> to configure the plain HTML <link/> tags returned by the `links` function above */}
				<Links />
			</head>
			<body>
				<p>Hello World</p>
			</body>
		</html>
	)
}
```
- Remix provides a [`<Link>` component](https://remix.run/docs/en/main/components/link) that you can use to create links (`<a>`) to other pages in your application without triggering a full-page refresh (which is what clicking a regular `<a>` will do). Prefer a [`<NavLink/>`](https://remix.run/docs/en/main/components/nav-link) for the support of styling active and pending states.
- [Prefetch](https://remix.run/docs/en/main/components/link#prefetch) the links that you expect the user to visit frequently.

### Relative links
#### The `relative` prop
- Assume we're having these routes after running `npx remix routes`:
```tsx
<Routes>
  <Route file="root.tsx">
    <Route index file="routes/index.tsx" />
    <Route path="users/kody" file="routes/users+/kody.tsx" />
    <Route path="users/kody/notes" file="routes/users+/kody_+/notes.tsx">
      <Route index file="routes/users+/kody_+/notes.index.tsx" />
      <Route path="some-note-id" file="routes/users+/kody_+/notes.some-note-id.tsx" />
    </Route>
  </Route>
</Routes>
```
To go back one level (`to='..'`) from the `users/kody/notes` path, there are 2 options:
1. Relative to the ***path*** (back to `users/kody`): in `notes.tsx`, define a `<link/>` like: 
```tsx
<NavLink to=".." relative="path" className="underline">
	Back to User
</NavLink>
```
2. The default: relative to the ***route*** (back to `/`, because that's the direct parent of `users/kody/notes` in terms of the route hierarchy): use `relative="route"` instead (or just not specified `relative="route"` at all, because it's the default).
#### Relative & absolute path
In `kody.tsx`, consider 2 cases:
```tsx
// Relative path, takes you to `users/kody/notes`:
<Link to="notes" className="underline">
	Notes
</Link>

// Absolute path, redirects to `/notes` no matter which route you're at:
<Link to="/notes" className="underline">
	Notes
</Link>
``` 

# Navigation
- The `useNavigation` hook provides information about a pending page navigation:
```tsx
import { useNavigation } from "@remix-run/react";

function SomeComponent() {
  const navigation = useNavigation();

  return (
     // This form has the `email` field, and the `Delete` button will be disabled when the `POST` request is pending
	<Form method="post" action="/signup">
	  <input name="email" />
	  <Button
		  name='intent'
		  value='delete'
		  disabled={navigation.formData?.get('intent') === 'delete'}
	  >
		  Delete
	  </Button>
    </Form>;
  )  
}
```

- Use the `<ScrollRestoration/>` to emulate the browser’s scroll restoration on location changes after loaders have completed. This can be particularly useful in cases where you have a sidebar or a multi-step form, and you ***want*** the scroll position to be reset to the top of the window when the form is submitted:
```tsx
import {
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

export default function Root() {
  return (
    <html>
      <body>
        {/* ... */}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
```
 To customize the behavior of `<ScrollRestoration/>`, check [this](https://youtu.be/4_H8j3rkpjI?si=YSGQfo3ACs_FZc6P&t=109) out.
 To opt out the behavior of `<ScrollRestoration/>` for particular `<Link/>`s or `<Form/>`s, add the `preventScrollReset` prop to them. But keep in mind that this *does not* prevent the scroll position from being restored when the user comes back to the location with the *back/forward buttons*, it just prevents the reset when the user clicks the link.