- Remix has a built-in router that enables you to easily map URLs and route parameters to files in your application's `app/routes` directory. Run the command `npx remix routes` to view the generated routes.
- If a route doesn't have a `default` export then it'll be treated as a [[Routing & Navigation#Resource routes|resource route]].
- Check out [this demo](https://interactive-remix-routing-v2.netlify.app).
----
# Nested routes
- For nested routes, use the `<Outlet/>` component as a *layout* wrapper for child layouts:
```tsx
// When you navigate to `/parent/child` url path, you'll see "Parent" above "Child". If we swap the `<h1>` and `<Outlet />` in the <Parent/>, then the "Child" will be above the "Parent". The parent gets to decide where its child goes.
//-----------------------------------
// app/routes/parent.tsx
export default function Parent() {
	return (
		<div>
			<h1>Parent</h1>
			<Outlet />
		</div>
	)
}

// app/routes/child.tsx
export default function Child() {
	return <h2>Child</h2>
}
```

## Conventions
### Flat routes
- Checkout the [v2 update](https://remix.run/docs/en/main/start/v2#upgrading-to-the-new-convention). TL;DR: no more folder-based routing, only file-based route is available.
- Enabled by the [remix-flat-routes](https://github.com/kiliman/remix-flat-routes) package, the `+` (or a `.` that's *not* right before the file extension) in a pathname indicates a parent segment. For example, path `users/random` will be defined (in your project's structure) as `routes/users+/random.tsx` or `routes/users.random.tsx` where the former enables a hierarchy in *directory manner* (`routes > users+ > random.tsx`) and the latter is defined as is. In either case, the entire UI generated by `random.tsx` is included in the `/users` path.
  > It's good practice to go as far as 3 levels of nested routes using the `+` convention. Any deeper than that should be defined using the `.`

- If you want a child pathname segment to have its **UI separated to a new page** (i.e. its layout is decoupled from the UI of its *direct* parent pathname), add an underscore (`_`) to its parent. For example, the `users/username/notes` path will have the UI of `notes.tsx` decoupled from `users/username` if we define the route as `routes/users+/username_+/notes.tsx`. In this case, `users/username` and `users/username/note` pathnames are ***treated as siblings*** (i.e. the `users/username/note` UI doesn't include the UI from `users/username`).
  > It's good practice to have the `_` precede the `+`

### Index route
- Use an index route in case you want a **dedicated** UI for a parent path by adding a `._index` right before the file extension. For example within the file path `routes/users+/random_+/note._index.tsx`, you'll have a dedicated UI when visiting `/users/random/note` which doesn't persist through `users/random/note/some-note`.
	- If you don't have an index route and put that "index UI" part to the `routes/users+/random_+/note.tsx` file instead, you'll get a clustered UI when visiting `users/random/note/some-note` because the UI of `some-note.tsx` is now rendered on top of that "index UI" part.

### Route params
- Define your route segments dynamically by having the `$` precedes the corresponding file name:
```ts
Route definition: app/routes/chats+/$chatId.messages.tsx
								  // ^ Route param
Resulting path: /chats/whatever/messages 
```
- You can get the ***current*** param value (e.g. `whatever` from the above example) from [`useParams()`](https://remix.run/docs/en/main/hooks/use-params) which you can `import` from `@remix-run/react`:
```tsx
import { useParams } from '@remix-run/react'

export default function PetRoute() {
	const params = useParams()
	return <h1>Hello {params.chatId}</h1>  // Hello whatever
}
```
- Child routes inherit all params from their parent routes, so `useParams()` can also get those params.
- Child routes have access to the data returned by their parent routes as well (using the [`useRouteLoaderData`](https://remix.run/docs/en/main/hooks/use-route-loader-data)hook:
```ts
const { user } = useRouteLoaderData<typeof rootLoader>('root')
```
# Resource routes
- Think of them as side-effect routes. Preferred in use cases for ***URLs that don't return UI***, e.g. use the path `/images/some-image-id` to get an image. These kind of route requests expect JSON, or plaintext, or an image. In some cases these requests could be non-GET requests as well.
- Resource routes are designed to be standalone and handle their own data fetching, which means that the [`loader`](https://remix.run/docs/en/main/route/loader) in the `app/root.tsx` will not be run whenever we access a resource route. 
- A quick tip to differentiate between a regular route (which is expected to display some kind of UI - i.e. returns JSX) and a resource route is that the resource route's definition file ***doesn't*** have a `export default` component in it.
# Splat route
- A splat route (`$.`) will match the rest of a URL from it, including the slashes.
- For example, a `/beef/and/cheese` path is matched by the `app/routes/$.tsx` splat route, a `/files/talks/remix-conf.pdf` (and any possible `/` after that) will be matched by  `app/routes/files.$.tsx`
```tsx
// In app/routes/$.tsx:
// This is called a "splat route" and as it's in the root `/app/routes/`
// directory, it's a catch-all. If no other [defined] routes match, this one will and we can know that the user is hitting a URL that doesn't exist. // By throwing a 404 from the loader, we can force the `ErrorBoundary` to render which will
// ensure the user gets the right status code and we can display a nicer error message for them than the Remix and/or browser default.

import { Link, useLocation } from '@remix-run/react'
import { GeneralErrorBoundary } from '#app/components/error-boundary.tsx'

export async function loader() {
	throw new Response('Not found', { status: 404 })
}

export default function NotFound() {
	// due to the loader, this component will never be rendered, but it's here so that there's a `default` export for this route to be treated as a normal UI route rather than a resource route
	return <ErrorBoundary />
}

export function ErrorBoundary() {
	const location = useLocation()
	return (
		<GeneralErrorBoundary
			statusHandlers={{
				404: () => (
					<div className="flex flex-col gap-6">
						<div className="flex flex-col gap-3">
							<h1>We can't find this page:</h1>
							<pre className="whitespace-pre-wrap break-all text-body-lg">
								{location.pathname}
							</pre>
						</div>
						<Link to="/" className="text-body-md underline">
							Back to home
						</Link>
					</div>
				),
			}}
		/>
	)
}
```
# Links
- Use the `<Links/>` component to dynamically access the HTML `<link/>` tags from anywhere in your project (that being said, in those files that don't have access to the `<head/>` tag). For example, you can use the `links` to apply [[Routing & Navigation#Resource routes|resource routes]] from any page, in this case, all the text from the `user/username` will be red, but its sibling route, e.g. `/users/username/notes` is unaffected:
```tsx
// Resource route: app > routes > resources+ > paint-it-red.tsx
export async function loader() {
	return new Response('body { color: red !important }', {
		headers : {
			'content-type': 'text/css'
		}
	})
}

// In a resource consumer route: app > routes > users+ > $username.tsx
import { type LinksFunction } from '@remix-run/node'
import { Link, useParams } from '@remix-run/react'

export const links: LinksFunction = () => {
	return [{ rel: 'stylesheet', href: '/resources/paint-it-red' }]
}

export default function UserProfile() {...some tsx}
```

- You can also get your resources dynamically cached on the browser:
```tsx
import { type LinksFunction } from '@remix-run/node'
import { Links } from '@remix-run/react'
import faviconAssetUrl from './assets/favicon.svg'
import fontStylesheetUrl from './styles/font.css'
import tailwindStylesheetUrl from './styles/tailwind.css'

// The browser automatically invalidates the cache whenever there's an update on these resources:
export const links: LinksFunction = () => {
	return [
		{ rel: 'icon', type: 'image/svg+xml', href: faviconAssetUrl },
		{ rel: 'stylesheet', href: fontStylesheetUrl },
		{ rel: 'stylesheet', href: tailwindStylesheetUrl },
	]
}

export default function App() {
	return (
		<html lang="en">
			<head>
			{/* Using Remix's <Links/> to configure the plain HTML <link/> tags returned by the `links` function above */}
				<Links />
			</head>
			<body>
				<p>Hello World</p>
			</body>
		</html>
	)
}
```
- Remix provides a [`<Link>` component](https://remix.run/docs/en/main/components/link) that you can use to create links (`<a>`) to other pages in your application without triggering a full-page refresh (which is what clicking a regular `<a>` will do). Prefer a [`<NavLink/>`](https://remix.run/docs/en/main/components/nav-link) for the support of styling active and pending states.
- [Prefetch](https://remix.run/docs/en/main/components/link#prefetch) the links that you expect the user to visit frequently.

### Relative links
#### The `relative` prop
- Assume we're having these routes after running `npx remix routes`:
```tsx
<Routes>
  <Route file="root.tsx">
    <Route index file="routes/index.tsx" />
    <Route path="users/kody" file="routes/users+/kody.tsx" />
    <Route path="users/kody/notes" file="routes/users+/kody_+/notes.tsx">
      <Route index file="routes/users+/kody_+/notes.index.tsx" />
      <Route path="some-note-id" file="routes/users+/kody_+/notes.some-note-id.tsx" />
    </Route>
  </Route>
</Routes>
```
To go back one level (`to='..'`) from the `users/kody/notes` path, there are 2 options:
1. Relative to the ***path*** (back to `users/kody`): in `notes.tsx`, define a `<link/>` like: 
```tsx
<NavLink to=".." relative="path" className="underline">
	Back to User
</NavLink>
```
2. The default: relative to the ***route*** (back to `/`, because that's the direct parent of `users/kody/notes` in terms of the route hierarchy): use `relative="route"` instead (or just not specified `relative="route"` at all, because it's the default).
#### Relative & absolute path
In `kody.tsx`, consider 2 cases:
```tsx
// Relative path, takes you to `users/kody/notes`:
<Link to="notes" className="underline">
	Notes
</Link>

// Absolute path, redirects to `/notes` no matter which route you're at:
<Link to="/notes" className="underline">
	Notes
</Link>
``` 

# Navigation
- The `useNavigation` hook provides information about a pending page navigation:
```tsx
import { useNavigation } from "@remix-run/react";

function SomeComponent() {
  const navigation = useNavigation();

  return (
     // This form has the `email` field, and the `Delete` button will be disabled when the `POST` request is pending
	<Form method="post" action="/signup">
	  <input name="email" />
	  <Button
		  name='intent'
		  value='delete'
		  disabled={navigation.formData?.get('intent') === 'delete'}
	  >
		  Delete
	  </Button>
    </Form>;
  )  
}
```

- Use the `<ScrollRestoration/>` to emulate the browser’s scroll restoration on location changes after loaders have completed. This can be particularly useful in cases where you have a sidebar or a multi-step form, and you ***want*** the scroll position to be reset to the top of the window when the form is submitted:
```tsx
import {
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

export default function Root() {
  return (
    <html>
      <body>
        {/* ... */}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}
```
 To customize the behavior of `<ScrollRestoration/>`, check [this](https://youtu.be/4_H8j3rkpjI?si=YSGQfo3ACs_FZc6P&t=109) out.
 To opt out the behavior of `<ScrollRestoration/>` for particular `<Link/>`s or `<Form/>`s, add the `preventScrollReset` prop to them. But keep in mind that this *does not* prevent the scroll position from being restored when the user comes back to the location with the *back/forward buttons*, it just prevents the reset when the user clicks the link.
## Non-navigation requests
- In Remix, we have a `<Form />` component for navigation and `useNavigation` to have information about the current navigation. We can do this because there can only be one navigation at time. However, with non-navigation mutations, you can have many of them at once, and `useFetcher` gives us the ability to handle those mutations.
- `useFetcher()` gives us the ability to perform any kind of fetch request. It definitely can result in a redirect, but often does not. It still uses `loader`s for `GET`s and `action`s for `POST`s, but all the information about the request is contained within the `fetcher` object itself:
```ts
import { useFetcher } from '@remix-run/react'

function SomeComponent() {
	const fetcher = useFetcher()

	// trigger the fetch with these
	const ui = <fetcher.Form {...formOptions} />
	// for imperative fetches:
	useEffect(() => {
		// to submit data
		fetcher.submit(data, options)
		// or to get data:
		fetcher.load(href)
	}, [fetcher])

	// build UI with these
	fetcher.state
	fetcher.formMethod
	fetcher.formAction
	fetcher.formData
	fetcher.formEncType
	fetcher.data
}
```
## Protecting routes
- The concept of protecting a route is pretty simple: Check the request, and if it's coming from a user who doesn't have a valid session, then redirect them to the login page:
```tsx
//-------------------- utils/auth.server.ts
export async function requireUserId(request: Request) {
	const userId = await getUserId(request);
	if (!userId) {
		throw redirect('/login');
	}
	return userId;
}

//-------------------- profile.tsx 
export async function loader({ request }: DataFunctionArgs) {
	const userId = await requireUserId(request)
	const user = await prisma.user.findUnique({
		where: { id: userId },
		select: { username: true },
	})
	invariantResponse(user, 'User not found', { status: 404 })
	return json({})
}
```
