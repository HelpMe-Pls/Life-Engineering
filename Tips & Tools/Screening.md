---
share_link: https://share.note.sx/zui2xf8v#3yc4gCDdoR39+YtOsnkQT0F5g8OQUBzF9ni5NyJYreM
share_updated: 2025-07-03T16:58:49+07:00
---
- This stage typically last for 1-2 rounds. 
	1. With the recruiter: briefly introduce your current role, your stack and what are your responsibilities. Maybe some mundane technical questions. 
	2. With the HR/Engineering Manager: same questions, but deep dive and ask more follow-up questions based on your answers.
	3. People sleep on this, but you can make a difference by presenting a positive first impression. 
---
# Technical
- If you can explain these concepts in Layman's language, you've got one foot in the door already.
## Concepts
### Network
- [[Networking#What happens when an user type an URL in the address bar and hit enter? |This question]].
- **HTTPS**: it's a protocol for transferring resources (like text, HTML pages, images) over the internet.
	- The **S** stands for the "secure" part which encrypts the connection between your browser and the site (with TLS), keeping your information private.
- **HTTP Methods**: these are like _verbs for the web_, telling the server which action to take for a request.
	- Mention idempotency & `POST` requests.
- **DNS**: translates easy-to-remember website names (like `google.com`) into the numerical addresses (IP addresses) computers use to find each other.
- **APIs**: they're _contracts_ that allow different software programs to ==_talk to each other_== and exchange information or request services _==in a structured way==_.
- **REST**: is a popular set of rules or style guide for building APIs. It makes them predictable and easier for different programs to communicate effectively.
- **Serverless**: is a cloud model where providers manage infrastructure, offering cost-efficient, auto-scaling execution for event-driven code. 
	- The main tradeoff are cold-start latency, cost predictability, and vendor lock-in.
### Auth
- **Authentication vs Authorization**: Authentication is verifying _who you are_ (like showing your ID card). 
	- Authorization is determining _what_ you are allowed to do once identified (like having the key to open a specific door).
- **Cookies**: help sites remember you or your preferences between visits, like keeping you logged in.
	- They're initially ==_set from the server and sent to the browser_==, then they're exchanged between the server and the browser to _==keep track of users' states==_.
	- Use them _==when you want server‑controlled, easily revocable sessions in browser‑centric apps==_, leveraging `HttpOnly`/`SameSite` to mitigate XSS/CSRF.
- **Session**: it's the server's way of remembering your ongoing visit after you logged in. 
	- It often _==**uses a cookie** containing a unique ID==_ as a temporary "passport" to recognize you on subsequent requests.
- **API Token**: it is a simple, opaque credential (usually a random string) that clients present to ==prove their identity to an API _**after** authentication_==. On receipt, the server looks it up in a secure store (e.g. Redis, database) and grants access based on the associated permissions.
	- Generated by the server and _==stored in cookies==_.
	- Use it when you need _==maximum control **and simplicity**==_ (especially service‑to‑service, CI/CD, microservices authentication)
- **JWT**: it's a compact, secure digital "ticket" that a server gives your browser ==_**after** you log in_==. It contains verifiable information about you, so you don't have to log in _again_ for every action.
	- It's _==a type of API Token==_ that offers additional features and benefits. Therefore, it's also generated by the server and stored in cookies.
	- Use them _==when you need **stateless**, cross‑domain, or **non‑browser client auth**==_ (SPAs, mobile, microservices), accepting extra work for revocation and XSS hardening.
### Frontend
- **Core Web Vitals**: those are the _==key measurements Google uses to judge a webpage's user experience==_. 
	- They focus on loading speed, how quickly you can interact with the page, and whether the layout jumps around unexpectedly.
- **localStorage vs sessionStorage**: both are ways for websites to store small amounts of data in your browser.
	- `localStorage` keeps the data even after you close the browser, while `sessionStorage` clears it when the browser tab is closed.
- **CSS Specificity**: it's the browser's conflict resolution system for styles by managing selectors' priority (Inline > IDs > Classes > HTML elements)
	- Understanding specificity is vital for predictable styling and avoiding reliance on `!important`, leading to more maintainable CSS.
- **CSS Flexbox vs Grid**:
	- Flexbox: choose it for _==one-dimensional layouts==_— either a row **or** a column (e.g. distributing space among items _==in a single direction==_ or for aligning items within a component).
	- Grid: when you need to manage a _==two-dimensional layout==_, controlling both rows **and** columns **simultaneously**. Ideal for _==overall page structure==_, complex component grids, or any layout where alignment in both dimensions is key.
- **React's state vs props**: `props` are like settings ==passed _down_ to a UI building block (component) from its parent, which the block _**itself can't change**_==. 
	- `state` is the component's own _internal_ memory or data that _**it can**_ manage and change over time.
### Backend
- **SSR vs SSG vs CSR**: how pages are rendered in these mode:
	- SSR: pages become dynamic (i.e. rebuilt) per request, hydrates _after_ static assets and data are loaded.
	- SSG: page are static by default, dynamic on hydration, data freshness is locked at build time.
	- CSR: pages are dynamic _after_ hydration, data freshness depends on `useEffect`
	- Performance ranking: SSG > SSR > CSR
- **SQL vs NoSQL**: they're two major types of databases. 
	- SQL databases organize data in structured tables with predefined columns (like Excel), while NoSQL databases are more flexible and can store data in various ways (like documents or key-value pairs).
	- ==SQL is better for _**secured and complex**_ queries, whereas NoSQL offers better _scalability and **flexibility**_==.
- **Promises vs callbacks**: callbacks manage asynchrony via nested functions, promises provide _==chainable objects representing eventual results==_, and async/await offers the most readable, synchronous-like syntax on top of promises.
- **Concurrency vs Parallelism**: concurrency is like a chef juggling multiple tasks by quickly switching between them on one stove.
	- Parallelism is like having multiple chefs working on different tasks at the exact same time.
- **Event loop**: it keeps applications responsive by _==enabling non-blocking asynchronous operations==_ in single-threaded JS by coordinating between the _**Call Stack**_ (for synchronous execution) and the **_Callback Queue_** (for holding callbacks for async tasks that have finished and are ready to run), _==moving callbacks to the stack for execution only **when the stack is empty**==_.
- **Thread vs Process**: Processes are _independent program instances_ with separate memory; ==threads are execution paths _within a process_== sharing memory.
	- To scale threads, NodeJS offers `worker_threads` to create _multiple threads within the same Node.js process_ where it's not waiting for something else; _==it's actively calculating==_ something to handle **CPU-bound tasks** that would block the main event loop.
	- To scale processes, NodeJS offers `cluster` module, `child_process` methods which allow you to spawn entirely **new Node.js processes** to _==achieve true parallelism==_ for **scaling network applications** (like an HTTP server) across multiple CPU cores and to improve **fault tolerance** (one process crashing doesn't bring down the others).
- **Database indexing**: Indexes speed up reads but can slightly slow down writes because the index also needs to be updated. Don't over-index (indexes take up storage space).
### Security
- **CORS**: browsers normally only let scripts on `siteA.com` talk to `siteA.com`; anything else is blocked. **CORS** [[Connections and protocols#CORS |adds headers]] so that browsers can safely relax their strict same-site rules.
- **[[Security#CSRF |CSRF]]**: it's an attack that tricks a logged-in user into unknowingly sending a command to a website they trust.
	- This malicious "command" is delivered when the user clicks on the attacker's bait resource (e.g. an image, a link to another website,...) which has different origin that you visit, and then when the user navigates back to their authenticated site, their upcoming requests are now riddled with these "commands".
	- Set `SameSite` in your cookie to prevent the browser from sending cookies **in cross-origin requests** unless allowed.
- **[[Security#XSS |XSS]]**: it's an attack where malicious code is sneakily injected into a website then the _==code runs in the browsers of unsuspecting visitors==_, potentially stealing their information.
	- _==Once XSS is in action, it also expose the users to CSRF attacks==_ since the malicious code runs with full access to same‑origin data, so CSRF tokens no longer block anything.
	- Set `HttpOnly` in your cookie to protect your server from stolen auth tokens via `document.cookie` in XSS payloads (this trick does _not_ stop XSS itself — it just limits what XSS can _do_). 



