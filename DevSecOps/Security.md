# CSRF
- Cross-Site Request Forgery, is a type of web security vulnerability where an attacker tricks a victim into performing actions they did not intend to on a web application where they're authenticated. 
	- Imagine a restaurant server bringing you a dish you didn't order, and you end up paying for it without realizing it.
- It's a good general practice to apply CSRF protection (by using cookie) to ***all requests that modify data***.
- To prevent CSRF vulnerabilities, there are a few foundational principles:
	1. **Use Anti-CSRF Tokens**: These are unique tokens generated by the server and sent to the client during session establishment. *If a request doesn't have the token, it will be denied.*
	2. **SameSite Cookies**: Setting it to `Strict` or `Lax` will ensure that the cookie isn't sent with cross-site requests.
	3. **Check the Origin Header**: Servers can check the `Origin` and `Referer` headers of incoming requests. If the request's origin isn't what the server expects, it can reject the request.
	4. **Always Logout**: Encourage users to log out of sessions when they're done, especially on public or shared computers. This reduces the window of opportunity for an attacker.
> [[Authentication#Logout|An example]]: rather than having a link to a `/logout` page which is too common, you should have a button that performs a `POST` request to `/logout` to leverage the built-in Same-Origin Policy of web browsers to prevent CSRF attacks from automatically triggering the logout operation.
> Besides, the logout functionality is considered a state-changing operation, as it modifies the user's session or authentication status, so a `POST` just makes more sense.
- Checkout [[Frontend/Frameworks/Remix/Data Transfer#CSRF|an implementation]].
>[!important]
> Cross-Site Scripting (XSS) can defeat all CSRF mitigation techniques. Therefore, it’s crucial to also have measures in place to prevent XSS attacks.
# XSS
- **Cross-Site Scripting** allows the attacker to execute unauthorized code within the victim's browser. It's like a hacker sneaking into a movie theater and playing their own movie on the big screen without permission.
- To prevent XSS attacks, websites should properly ***sanitize and validate user input***, ***encode output data***, and ==implement Content Security Policies== (CSP) on *both the server-side and the client-side* to restrict the execution of untrusted scripts:
```tsx
//--------------------- Server-side
const express = require('express');
const app = express();
const helmet = require('helmet');

// Set up Content Security Policy
app.use(
  helmet.contentSecurityPolicy({
    directives: {
// Allows resources to be loaded ONLY FROM the same origin (your website).
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", 'example.com'],
      styleSrc: ["'self'", 'fonts.googleapis.com'],
      fontSrc: ["'self'", 'fonts.gstatic.com'],
// Allows images to be loaded from your website, data URIs, and the specified domain (`example.com`)
      imgSrc: ["'self'", 'data:', 'example.com'],
// Restrict the URLs that can be used as the source of `<object>`, `<embed>`, and `<applet>` elements.
      objectSrc: ["'none'"],
      upgradeInsecureRequests: true,
    },
  })
);

// Rest of your application code...

//--------------------- Client-side
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' example.com; style-src 'self' fonts.googleapis.com; font-src 'self' fonts.gstatic.com; img-src 'self' data: example.com; object-src 'none'; upgrade-insecure-requests">
    <!-- Your other HTML code -->
  </head>
  <!-- ... -->
</html>
```